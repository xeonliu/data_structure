//
// Created by SJTU on 2023/1/19.
//

/** Class template 的声明和实现必须放在同一个头文件中！
 * */
#ifndef DATASTRUCTURE_SEQLIST_H
#define DATASTRUCTURE_SEQLIST_H

#include "list.h"
#include <iostream>
template<class elemType>
class seqList : public list<elemType>{
private:
    elemType *data; //指向数组首地址的指针
    int maxSize;    //动态数组的规模
    int currentLength;  //表长
    void doubleSpace(); //增加容量

public:
    seqList(int initSize = 10);
    ~seqList() override {
        delete[] data;
    }
    void clear();
    int length() const;
    void insert(int i, const elemType &x);
    void remove(int i);
    int search(const elemType &x) const;
    elemType visit(int i) const;
    void traverse() const;

};

/** The generate function */
template<class elemType>
seqList<elemType>::seqList(int initSize) {
    data = new elemType[initSize];
    maxSize = initSize;
    currentLength = 0;
}

/** Double the spaces generated by 'new' */
template<class elemType>
void seqList<elemType>::doubleSpace() {
    elemType *temp = data;
    maxSize*=2;
    data = new elemType[maxSize];
    for(int i=0;i<currentLength;++i){
        data[i] = temp[i];
    }
    delete[] temp;

}

/** Insert element x on index i.
 * Double the space when currentLength equals maxSize.
 * shift the elements
 * insert x
 * ++currentLength
 */
template<class elemType>
void seqList<elemType>::insert(int i, const elemType &x) {
    //Double the space when currentLength equals maxSize
    if (currentLength == maxSize)
        doubleSpace();

    //shift the elements
    for(int j = currentLength;j>i;--j){
        data[j]=data[j-1];
    }

    //fill in x
    data[i] = x;

    //++currentLength
    ++currentLength;



}


template<class elemType>
void seqList<elemType>::clear() {
    currentLength = 0;
}

template<class elemType>
int seqList<elemType>::length() const {
    return currentLength;
}


template<class elemType>
void seqList<elemType>::remove(int i) {
    for(int j=i;j<currentLength-1;++j){
        data[j] = data[j+1];
    }
    --currentLength;
}

template<class elemType>
int seqList<elemType>::search(const elemType &x) const{
    for(int i=0;i<currentLength;++i){
        if(data[i]==x){
            return i;
        }
    }
    return -1;
}

template<class elemType>
elemType seqList<elemType>::visit(int i) const {
    return data[i];
}

template<class elemType>
void seqList<elemType>::traverse() const {
    for(int i=0;i<currentLength;++i){
        std::cout << data[i] << ' ';
    }
}



#endif //DATASTRUCTURE_SEQLIST_H
